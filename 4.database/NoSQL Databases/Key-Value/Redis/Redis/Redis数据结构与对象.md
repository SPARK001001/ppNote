Redis 底层使用C语言实现

1. **简单动态字符串SDS**

   1. Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示

   2. 相比C字符串，有以下优势。

      ​	`SDS结构`: 

      ​	 int len ;(buf数组中已使用字节数量)

      ​	 int free;（未使用字节数量）

      ​	 char buf[] ;（字节数组，用于保存字符串）

      1. 常数复杂度获取字符串长度（通过len）
      2. 杜绝缓冲区溢出（先判断free，没有足够大小就扩容）
      3. 减少修改字符串长度时所需的`内存重分配`次数（两种优化策略）
         1. 空间预分配（若len小于1M,修改后新字符串长度为13，则分配free为13，len为13，总大小为13+13+1,1保存末尾空字符，以便更好复用c语言的函数库； 若len大于1M比如为30M, 预分配1M, 即 30M +1M +1byte）
         2. 惰性释放空间（将减少的空间记录在free上）
      4. 二进制安全（不对保存在其中的数据做任何限制、过滤，写进去啥样，读出来就是啥样）
      5. 兼容部分C字符串函数





2. **链表**

   1. 广泛应用于实现Redis的各种功能，如列表键、发布与订阅、慢查询、监视器等。

   2. 每个链表节点由一个ListNode结构表示，有前置节点和后置节点，为双端链表。（双端）

   3. 每个链表由list结构表示，有头节点指针head和表尾节点指针tail，以及长度信息。o(1)获取长度信息

   4. 链表表头节点后置节点和表尾节点的前置节点都指向null，所以链表为无环链表。（无环）

   5. 通过为链表设置不同的类型特定函数，redis的链表可以用于保存各种不同类型的值。（多态 ）

      

3. **字典**

   1. redis数据库 和 哈希键 使用`字典`作为底层实现，字典使用`哈希表`作为底层实现

      1. 哈希表 = 数组 + 链表
      2. 字典 = 两哈希表ht[2] + rehashidx(-1表示不在进行rehash)

   2.  hash算法 用来计算键的hash值，Redis使用murmurhash算法计算hash值，该算法优点有很好的随机分布性和很快的计算速度

   3. 解决键冲突：拉链法。使用头插法，为了速度考虑

   4. rehash步骤：

      1. 为字典的ht[1]分配空间，扩容（ht[0].used*2，used表示保存键值对数量，非占数组坑的大小）或缩容(ht[0].used) ，大于等于该值的第一个2的幂次方 
      2. 将ht[0] 上所有键值对rehash到ht[1]
      3. 都迁移完了，ht[0]为空，将ht[1]设为ht[0], 在ht[1]新创建一个空白哈希表，table=null,size=0,used=0,sizemask=0;

   5. 哈希表扩缩容时机：

      1. 服务器目前不在执行bgsave 或bgrewriteaof命令，并哈希表负载因子大于等于1.

      2. 服务器正在执行bgsave 或bgrewriteaof命令，并哈希表负载因子大于等于5. （避免在子进程存在期间（这两命令会创建子进程，操作系统采用`写时复制`优化子进程使用效率，会占用内存）进行扩展操作，节约内存）

      3. 负载因子小于0.1时，进行缩容操作

         `负载因子`: 哈希表已经保存的节点数量 / 哈希表大小   load_factor = ht[0].used / ht[0].size

   6. 渐进式rehash步骤: 分多次、渐进式完成，防止一次性rehash导致服务停止

      1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两哈希表
      2. 字典维持`索引计数器变量 rehashidx`,将值设置为0，表示rehash开始。
      3. rehash期间，对字典执行增、删、改、查操作，会同时将ht[0]上rehashidx索引位置所有键值对rehash到ht[1],完成后，rehashidx加1。(`之前还以为是执行操作的那个索引上的`)
      4. 不断执行直到，ht[0]上位置键值对都rehash到ht[1],rehashidx会被设置为-1，表示rehash操作已经完成了。

   7. rehash期间的哈希表操作

      1. `删、查、改`操作 先在ht[0]执行，没找到对应键去ht[1]执行
      
      2. `增` 操作在ht[1]执行，保证ht[0]包含键值对数量只减不增
      
         

4. **跳跃表**skiplist
   1. 跳跃表是有序集合的底层实现之一，是一种有序数据结构，通过在每个节点维持多个指向其他节点的指针，从而达到快速访问的目的。
   2. redis的跳跃表的实现由zskiplist 和 zskiplistNode 两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、最高层数（不含表头节点）、节点数量）， zskiplistNode用于表示跳跃表节点。
   3. 每个跳跃表节点的层高都是1到32的随机数（由幂次定律--越大的数出现的概率越小，生成）
   4. 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须唯一。
   5. 跳跃表中的节点按照分值大小进行排序，分值相同时，按照成员对象（是一个指针，指向一个字符串对象，字符串对象则保存着sds值）在字典序中的大小进行排序。支持平均O(logN),最坏O(N)的复杂度查找节点，还支持顺序性操作来批量处理节点。 
   6. 应用：实现有序集合；在集群节点中作为内部数据结构。



 	5. **整数集合**intset
      	1. 是集合键的底层实现之一
      	2. 整数集合的底层实现为数组，这个数组以``有序、无重复``的方式保存集合元素，在需要时，根据新添加的元素类型（整数长度int8 , int16）来改变这个数组的类型（升级操作）。
      	3. 升级操作为整数集合带来操作上的灵活性（不用写死整数类型），并尽可能的节约内存。
      	4. 整数集合只支持升级操作，不支持降级操作。
      	5. 新增元素、删除元素 O(N)时间复杂度，移动数组，考虑升级。查找元素，有序可以二分查找，O(logN);



6. **压缩列表**ziplist
   1.  压缩列表是一种为了节约内存而开发的顺序型数据结构
   2. 压缩列表被用作列表键和哈希键的底层实现之一
   3. 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或整数值；节点还保存前一个节点的长度，因此可以计算前一个节点起始地址，因此可以表尾向表头遍历。 
   4. 添加新节点或压缩列表，或者从压缩列表中删除节点，可能引发连锁更新操作，但出现几率不高。



7. **对象redisObject**
   1. Redis数据库中的每个键值对的键和值都是一个对象
   2. Redis共有`字符串、列表、哈希、集合、有序集合`5种类型的对象，每种类型至少有两种或以上的编码方式（底层数据结构），不同编码方式可以在不同的场景上优化对象的使用效率。
   3. 服务器在执行某些命令前，会先检查给定键的值对象的类型，通过redisObject对象的type属性。应用TYPE命令，看类型（TYPE key  -> 看值对象的类型string/list/hash/set/zset）
   4. Redis内存回收机制使用引用计数实现（redisObject的 refCount属性），一个对象不再被使用（refCount变为0）时，对象所占内存会被自动释放。
   5. Redis会共享值为0-9999的字符串对象。(只共享包含整数值的字符串对象)
   6. 对象会记录自己最后一次被访问的时间（redisObject的lru属性），可用于计算对象的空转时间。若服务器打开maxmemory选项，并使用内存回收算法为volatile-lru或allkeys-lru,当服务器占用内存大于maxmemory,空转时间长的优先被回收。