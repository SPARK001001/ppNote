1. **数据库**
   1. Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量由redisServer.dbnum属性保存
   
   2. 客户端通过修改目标数据库指针，让它指向redisServer.db数组中不同的元素来切换不同的数据库。
   
   3. 数据库主要由dict和expires两个字典组成，其中dict字典负责保存键值对，expires字典负责保存键的过期时间。
   
   4. 数据库由字典构成，所以数据库的操作都建立在字典的操作上。
   
   5. 数据库的键总是一个字符串对象，而值则可以使任意一种Redis对象类型，包括字符串对象、列表对象、哈希表对象、集合对象、有序集合对象。
   
   6. expires字典的键指向数据库中的某个键，值则记录了数据库键的过期时间，过期时间是一个以毫秒 为单位的unix时间戳。
   
   7. Redis使用`惰性删除和定期删除`两种策略来删除过期的键：惰性删除只是在碰到过期键时才进行删除操作，定期删除时每隔一段时间主动查找并删除过期键。
   
   8. 执行Save命令或bgsave命令生成RDB文件，不会包含过期的键。
   
   9. 执行bgrewriteaof命令重写产生的aof文件，不会包含过期的键。
   
   10. 当一个键过期被删除后，服务器会追加一条del命令到现有aof文件末尾，显式的删除过期键。
   
   11. 当主服务器删除一个过期键后，它会向所有从服务器发送一条del命令，显式的删除过期键。
   
   12. `从服务器即使发现过期键（命令调用之前会检查是否过期）也不会自作主张的删除它，而是等主服务器发来del命令，这种统一，中心化的过期键删除策略可以保证主从服务器数据的一致性。`
   
   13. 当Redis命令对服务器进行修改后，服务器会根据配置向客户端发送数据库通知。
   
   14. 命令：select 1 : 切换数据库； flushdb：清空整个数据库   ； TTL/PTTL:返回键的剩余生存时间，秒/毫秒为单位； persist key：删除键的过期时间 ； expire/pexpire/expireat/pexpireat  key .. :设置过期时间
   
       

2. **RDB持久化**

   1. RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。保存压缩的二进制文件。

   2. Save命令由服务器命令直接执行保存操作，会阻塞服务器。

   3. bgsave命令由子进程执行保存操作，不会阻塞服务器。

   4. 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行bgsave命令。`通过定时任务检查是否满足。默认3条件 save 900 1 (900秒内对数据库至少进行1次修改) ;save  300 10  ; save 60 10000`

   5. RDB文件是一个经过压缩的二进制文件，由多个部分组成。

   6. 对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。

   7. 命令： od -c dump.rdb  打印分析rdb文件   ；redis-check-dump  rdb文件检查工具。

      

3. **AOF持久化**

   1. 保存Redis服务器所执行的`写命令`来记录数据库的状态。命令以命令请求协议格式保存。

   2. aof文件写入和同步：**写入**指`aof bug `写入到`aof文件`（此时还没落盘），操作系统对文件的写入有个`内存缓冲区`，需要经过**同步**(操作系统调用fsync/fdatasync函数)才能将缓冲区的数据存到磁盘。

   3. aof持久化配置：appendfsync

      1. always : 将aof-buf中的所有内容写入并同步到aof文件。故障停机只会丢失一个事件循环（服务器进程就是一个事件循环，在循环中处理文件事件、时间事件、写入aof等）的命令数据。
      2. everysec : 将aof-buf（aof缓冲区）中数据`写入`aof文件，若距上次同步时间超1s，再次`同步`，由一个专门线程负责执行。故障停机 丢失1s数据。
      3. no : 将aof-buf数据写入aof文件，但同步时机由操作系统决定。

   4. `aof重写原理`：不对原来的aof文件操作，而是直接从数据库中读取键现在的值，然后用一条命令去记录键值对（若重写集合元素个数超64，会分成多个命令写，每个写64个元素），代替之前记录这个键值对的多条命令。

   5. aof后台重写：bgrewriteaof命令的实现原理

      1. 放到子进程执行重写：原因有二

         1. 子进程重写期间，服务器进程（父进程）可以继续处理命令请求。
         2. 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下保证数据的安全性。

      2. 子进程重写期间，父进程继续处理命令请求，可能会对数据库状态进行修改，导致当前数据库状态和重写后的aof文件保存的数据库状态不一致。处理步骤

         1. 使用aof重写缓冲区：在服务器创建子进程之后开始使用，当redis执行完一个写命令后，会同时将这个写命令发送给aof缓冲区（对现有aof文件处理工作如常进行）和aof重写缓冲区。

         2. 子进程aof重写完后，给父进程发送信号，父进程接收到后调用一个信号处理函数（会阻塞其他命令）：该函数会将aof重写缓冲区的内容追加写到新aof文件末尾使得新旧aof文件保存的数据库状态一致，并对新aof文件改名，原子覆盖现有aof文件，完成新旧文件替换。

=


4. **事件**
   1. Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。
   2. 文件事件处理器是基于Reactor模式实现的网络通信程序。
   3. 文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或可读（Readable）时，相应的文件事件就会产生。
   4. 文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE(写事件)两类。
   5. 时间时间分为定时事件（指定时间到达一次）和周期事件（每隔一段时间到达一次）
   6. 服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。
   7. 文件事件和时间事件是合作关系，服务器会轮流处理这两种事件，并且处理的过程也不会进行抢占。
   8. 时间事件的实际处理时间通常会比设定的时间到达晚一些。（时间事件在文件事件之后执行，并不会抢占） 



5. **客户端**
   1. 服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。
   2. 客户端输入缓冲区（由服务器记录在redisClient结构）记入客户端发送的命令请求，大小不能超过1g.
   3. 客户端输出缓冲区记录执行命令所得的命令回复。有两类，固定大小缓冲区（16k）和可变大小缓冲区(不能超过服务器设置的硬性限制值)
   4. 客户端关闭：网络连接关闭、发送不合协议格式的命令请求、称为client kill命令的目标、空转时间超时、输出缓冲区大小超出限制
   5. 处理lua脚本的伪客户端在服务器初始化时创建、知道服务器关闭。
   6. 载入aof文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕后退出。 

6. **服务端**
   1. 一个命令从发送到完成经过步骤：1）客户端将请求发送给服务端 2）服务器读取命令请求，并分析出命令参数 3）命令执行器根据参数查找命令的实现函数，执行实现函数得到命令回复 4）服务器将命令回复返回给客户端
   2. serverCron函数默认每100ms执行一次，主要工作是更新服务器状态信息、处理服务器接收的sigterm信号，管理客户端资源和数据库状态，检查并执行持久化操作等
   3. 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态 2）载入服务器配置 3）初始化服务器数据结构 4）还原数据库状态 5）执行事件循环

