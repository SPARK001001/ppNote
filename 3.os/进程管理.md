## 进程概念：

 - 了解进程的定义，进程是程序在执行过程中的一个实例，拥有独立的执行空间、程序计数器、堆栈和资源。

## 进程创建：

- 理解进程创建的过程，包括父进程创建子进程的方式，如`fork()`系统调用和`exec()`系列函数。步骤如下
  - 父进程调用***fork()***系统调用，操作系统创建一个与父进程相同（相同指程序、数据、环境、文件描述符等）的子进程，返回子进程的pid(进程id)给父进程，返回0给子进程。
  - 父进程和子进程继续执行，他们共享一些资源（代码和运行状态），但是在不同进程空间（资源独立，互不影响）中运行。
  - 子进程根据需要调用**exec()** 系列函数（execl()/execle()/execlp()/execv()/execve()），加载一个新的程序并执行，原有的数据和程序会被替换。
  - 第一个用户态进程由内核创建，称为为`init进程`或系统进程，linux系统中该进程的pid是1,,是系统中其他用户态进程的祖先，是整个进程树的根节点。init进程的作用是启动系统中其他进程，并监控它们的运行状态

## 进程调度：

- 了解进程调度算法，如先来先服务（FCFS）、短作业优先（SJF）、时间片轮转（Round-Robin）等。
  - 作用：进程调度算法是操作系统用来决定哪个进程获得cpu时间并执行的策略。
  - 先来先服务算法：
    - 按进程到达的先后顺序进行调度。
    - 适用于长作业时间的进程，但容易导致短作业等待时间长，产生饥饿现象
  - 短作业优先：
    - 选择执行时间最短的进行优先执行
    - 需要预先知道进程执行时间，适用于批处理环境，但对实时系统不适用。
  - 时间片轮转：
    - 将cpu时间划分为固定大小的时间片，每个进程按顺序获得一个cpu时间片，并在时间片用完后放回队列尾部。
    - 避免了长作业占用cpu时间过长，但对长时间的进程仍有较高等待时间。
  - 最高优先级优先：
    - 每个进程赋予一个优先级，优先级最高的先执行
    - 可能导致低优先级的进程长时间等待
  - 最短剩余时间优先
    - 动态版本的短作业优先算法，每次选择剩余执行时间最短的进程执行
    - 需要预先知道进程执行时间，适用于批处理环境
  - 多级反馈队列：（linux系统使用的进程调度算法）
    - 将进程队列划分成多个优先级队列，并为每个优先级队列分配不同的时间片大小。优先级较高的队列获得较小的时间片，优先级较低的队列获得较大的时间片。
    - 可以灵活调整不同队列的调度策略。如优先级较高的队列使用短作业优先算法调度，优先级较低的队列采用时间片轮转算法调度，满足不同进程的需求
    - 工作原理
      - 进程进入系统，会被先分配到最高优先级队列，获得较小的时间片，优先执行。如果进程在该时间片执行完成，那么进程会被从队列中移除，没执行完，则被移到下一级优先级队列，获得较大的时间片。
      - 优先级较高的进程有更多机会获得cpu执行时间，提高的响应速度。优先级较低的进程也有机会执行，避免长时间等待，从而实现公平的调度。

## 进程状态：

- 掌握进程的不同状态，如就绪状态、运行状态、阻塞状态等，以及状态之间的转换条件。
  - 就绪状态(Ready)：进程获取了所有必需的资源，并等待分配cpu时间以执行。就绪状态的进程通常排列在**就绪队列**中，等待调度程序选择其中一个进程并将其设置为运行状态。
  - 运行状态(Running)：就绪状态的进程被调度执行，占用cpu资源，执行其指令。
  - 阻塞状态（Blocked）：进程等待某些事件发生时被阻塞，例如等待输入输出操作完成或等待某个信号。处于阻塞状态的进程不会被调度执行（不占用cpu），直到满足等待的条件，然后会被转换回就绪状态。
  - 创建状态（New）：进程正在被创建，正在分配必要的资源，并将其设置为就绪状态，等待执行。
  - 终止状态（Terminated）: 进程的执行已经结束，可能是正常结束或因为发生错误而异常终止。终止状态的进程会释放其占用的资源，并从系统中移除。
- 进程的状态之间的转换由操作系统的调度器和内核管理，根据进程的执行情况和资源的可用性进行动态调整。

## 进程同步：

- 了解进程同步的机制，如信号量、互斥锁、条件变量等，以及如何避免竞态条件和死锁。
- 旨在多进程环境中，为保证共享资源的正确访问和避免竞态条件而采取的一些机制。这些机制可以确保多个进程之间按照一定的顺序来访问共享资源，从而避免数据的不一致性和冲突。
  - 信号量（semaphore）：是一个计数器，用于控制对共享资源的访问。当进程要访问资源时，先检查信号量，大于0则资源可用。等于0表示不可用，进程需等待。通过信号量，可实现对临界区的互斥访问。
  - 互斥锁（mutex）:是一种二进制信号量，只有两状态：锁定和解锁。先获取锁才能进入临界区访问共享资源。只有一个进程能进入临界区。
  - 条件变量（condition variable）:条件变量用于在多进程或多线程环境下等待某个特定条件的发生。当进程需要等待某个条件满足时，可以调用条件变量的等待操作，使得进程暂时释放资源，并进入等待状态；当条件满足时，其他进程可以通过条件变量的**通知操作唤醒**等待的进程。
  - 读写锁（read-write lock）: 是一种特殊的互斥锁，用于在多读单写的场景提高并发性能。允许多个进程同时对共享资源进行读操作，但只允许一个进程进行写操作。
- 为避免竞态条件和死锁，需要合理使用同步机制
  - 避免在临界区内阻塞：避免阻塞其他进程的执行
  - 不可抢占性：在进程访问共享资源时，将临界区设为不可抢占，确保临界区的执行不会被中断。
  - 正确释放资源：使用进程同步机制时，必须正确释放已经获得的锁或信号量，避免出现资源泄漏或死锁。

## 进程通信：

- 掌握进程间通信的方法，如管道、消息队列、共享内存、信号等。
- 是指在多进程环境中，不同进程之间进行数据交换和信息传递的机制。常见通信方法如下：
  - 管道（pipe）:是一种单向的进程间通信方式，分为无名管道和命名管道。无名管道用于有亲缘关系的父子进程之间的通信。命名管道可以用于没有亲缘关系的进程之间的通信。管道数据流动是单向的，数据从进程的输出端流向另一个进程的输入端。
  - 消息队列（message queue）:是一种进程之间的通信机制，实现不同进程之间的异步通信。进行可以向消息队列收发消息。消息队列通过消息的标识符来区分不同的消息，进程可以根据标识符来选择接收特定类型的消息。
  - 共享内存（shared memory）:是一种进程通信的高效方式，多个进程可以映射同一段共享内存区域到自己的地址空间，从而实现数据的共享。进程可以直接读写共享内存区域，而无需通过中间介质进行数据的传输。
  - 信号（signal）: 是一种异步通信机制，用于通知进程发生了某种事件。一个进程可以向另一个进程发送信号，接收信号的进程在接收到信号后会执行相应的信号处理函数。
  - 套接字（socket）:是一种用于网络通信的通用的进程间通信机制。可用于同一台机器上不同进程之前的通信，也可以用于在不同机器上的进程之间通信

## 进程终止：

- 了解进程终止的方式，包括正常终止和异常终止，以及如何回收进程的资源。
  - 进程终止方式：
    - 正常终止：进程在完成任务后，调用exit() 系统调用或从main()函数中返回来正常终止。在正常终止时，进程会释放它所占用的资源，并向它的父进程发送一个退出状态码，用于传递进程的退出状态信息。
    - 异常终止：进程可能因为发生了错误或者异常的情况而异常终止。进程会向它的父进程发送异常终止信号，父进程可以通过捕获该信号来处理进程异常终止情况
    - 信号终止： 进程可以收到来自操作或其他进程发送的信号，这些信号可以导致进程终止。如收到SIGKILL信号会立即终止进程，而收到SIGTERM信号会请求进程正常终止
    - 被动终止：进程可能会因为父进程的终止而被动终止。当父进程终止时，它的子进程可能会被init进程接管，并被init进程杀死。
  - 当一个进程终止时，它的资源将被回收。操作系统会释放进程占用的内存，文件描述符等资源，并将进程表中的进程条目删除。如果该进程是其他进程的子进程，它的退出状态信息将被保存，供父进程通过调用wait() 或waitpid()来获取。

## 守护进程：

- 理解守护进程的概念和特点，以及守护进程的创建和管理方式。

- 守护进程是在后台运行的一种特殊类型的进程，他在操作系统启动时被创建，一直运行到操作系统管理或者被手动终止。

  - 守护进程通常由系统管理员或者系统启动脚本创建，在系统启动时自动运行。
  - 守护进程没有控制终端，与用户无关，不会受用户登录和注销的影响。
  - 守护进程通常在后台运行，不会向终端输出信息，也不会接受终端输入。
  - 守护进程通常负责系统级的任务，如定时任务、日志记录、网络服务等。

- 守护进程创建步骤：

  - 创建一个子进程，然后使父进程退出。这样子进程就不会成为孤儿进程，会被`init`进程接管。
  - 在子进程中调用`setsid()`系统调用创建一个新的会话，并使子进程成为会话的领头进程。这样可以让守护进程独立于终端，不会受终端的影响。
  - 关闭所有已打开的文件描述符，因为守护进程不会使用终端，也不会需要和用户交互，所以所有终端相关的文件描述符都应该关闭。同时，还应该关闭其他不需要的文件描述符，以避免浪费系统资源。
  - 改变守护进程的工作目录到一个安全的位置，通常是根目录`/`。这样可以避免守护进程在执行期间影响其他目录的文件操作。
  - 重定向标准输入、标准输出和标准错误输出到`/dev/null`或者其他文件。由于守护进程不会向终端输出信息，将输出重定向到`/dev/null`可以丢弃所有输出，以免干扰其他进程。
  - 执行守护进程的初始化工作，准备好运行所需的资源和环境。
  - 完成初始化后，守护进程进入正常工作状态，执行它的任务。

  值得注意的是，在第2步中调用`setsid()`系统调用的目的是创建一个新的会话并脱离终端，这样可以确保守护进程不会受到终端关闭、断开等影响，保持在后台运行。在第5步中重定向标准输入、标准输出和标准错误输出到`/dev/null`是为了丢弃所有输出，因为守护进程通常不会向终端输出信息。这样做可以避免输出被打印到终端，同时也可以避免因输出导致的文件描述符泄露。

## 进程组和会话：
- 了解进程组和会话的概念，以及它们在进程管理中的作用。

  - 进程组（process group）：是一组关联的进程的集合。在一个进程组中，一个进程可以是组长，其他进程是组员。组长进程的进程id(pid)是组id(pgid),而其他进程的pgid与组长进程id相同。进程组作用之一是方便对组内进程进程管理，比如向整个组发送信号。
  - 会话(session)： 是一个或多个进程组的集合。通常情况下，一个会话包含一个前台进程组（前台运行）和若干个后台进程组（后台运行）。会话的一个重要作用是为了在终端断开连接后，将终端的所有进程组发送sighup信号，通知他们终端已经关闭。

  在linux和unix系统中，一个会话通常是从用户登录开始到用户注销或者终端关闭结束。在一个会话中，可以有多个终端和多个作业，每个作业可以包含一个或多个进程。

  进程组和会话的创建通常通过系统调用setpgid() 和setsid()来实现。setpgid() 用于将一个进程添加到指定的进程组，而setsid()用于创建一个新的会话。

##  线程管理：
- 了解线程的概念和与进程的区别，以及线程的创建、同步和通信。
  - 线程是进程中的执行单元，一个进程可以包含多个线程，这些线程共享进程的资源，包括内存空间和文件描述符等。线程和进程的主要区别在于资源的拥有和使用方式：
    - 线程是进程中的执行单元，多个线程共享一个进程的资源，而进程有自己独立的地址空间和资源。
    - 创建线程比创建进程更轻量级，切换开销小，因此线程间的通信和同步更高效。
  - 线程创建：可以通过系统调用或线程库提供的函数来创建。在c语言中，可以使用pthread_create函数来创建线程，在java中，可以使用Thread类或Runnable接口来创建线程。
  - 线程同步：由于线程共享进程的资源，因此可能或导致多个线程同时访问共享资源而产生竞态条件。为避免竞态条件，需要采用线程同步机制，如互斥锁、信号量、条件变量等，来保证多个线程之间的访问顺序和正确性。
    - 竞态条件是指当多个线程或进程同时访问共享资源，并且对资源的访问顺序不确定时，最终的结果取决于不同线程或进程执行的顺序。这种情况下，由于资源的访问时并发进行的，可能导致意外的结果或者错误的计算。
  - 线程通信：用于传递数据或者协调工作，常见机制有共享内存和消息传递。
##  多核处理器：
- 了解在多核处理器上的进程管理和线程调度，以及如何充分利用多核资源。
  - 为了实现多核处理器上的进程管理和线程调度，操作系统需要支持并发执行和并行执行。
    - 并发执行是过个进程或线程在同一时间段内同时执行，但不一定是在多个处理器核心上同时执行，而是通过时间片轮转等调度算法，在一个核心上快速切换执行多个进程或线程，从而使他们看起来是在同时执行。
    - 并行执行是指多个进程或线程在多个处理器核心上真正的同时执行，每个核心复制执行一个进程或线程，从而实现真正的并行计算，进一步提高系统的性能和响应速度。
  - 为了实现多核处理器上的进程管理和线程调度，操作系统需要具备以下功能和特性：
    1. 硬件支持：多核处理器需要支持硬件级别的多线程执行，包括多核心和超线程技术等。
    2. 进程调度：操作系统需要实现进程调度算法，确保多个进程能够在多核处理器上公平地获得执行时间，并充分利用所有核心的计算资源。
    3. 线程管理：操作系统需要支持线程创建和销毁，以及线程的同步和通信机制，确保多个线程能够在多核处理器上正确地协作执行。
    4. 负载均衡：操作系统需要具备负载均衡的能力，将任务均匀地分配到各个核心上，避免某些核心负载过重而造成资源浪费。
    5. 优化技术：操作系统可以采用一些优化技术，如就近调度、线程亲和性等，以提高多核处理器上的任务执行效率。
## 中断和异常处理：
- 了解中断和异常的概念，以及操作系统如何处理不同类型的中断和异常。
  - 中断和异常是计算机系统中常见的事件处理机制，用于处理硬件或软件产生的特定事件，例如外设的请求、错误、系统调用等。操作系统通过中断和异常处理机制来响应这些事件，并进行相应的处理
  - 中断是由外部设备或外部信号触发的事件，用于通知操作系统有特定的任务要处理。当中断发生时，处理器会立即中断当前执行的任务，保存当前的执行现场，并跳转到中断处理程序中执行。中断处理程序是预先定义好的，用于处理不同类型的中断事件。处理完中断事件后，处理器会恢复之前的执行现场，并继续执行被中断的任务。
  - 异常是由于程序执行错误或非法操作而触发的事件，例如除零错误、非法指令、内存访问越界等。异常是由cpu内部产生的，用于通知操作系统有错误或异常情况需要处理。当一个异常发生时，处理器会立即中断当前执行的任务，保存当前的执行现场，并跳转到异常处理程序中执行。异常处理程序也是**预先定义**好的，用于处理不同类型的异常事件。处理完异常事件后，处理器会恢复之前的执行现场，并继续执行被中断的任务。
  - 保存现场、执行中断处理程序或异常处理程序、恢复现场
##  进程间资源共享：
- 了解进程间共享资源的问题，如共享文件、共享内存等，以及如何保证数据的一致性和安全性。

- 进程间资源共享是指多个进程之间共同使用某些资源，如文件、内存等。在进程间共享资源时，需要注意以下问题，以确保数据的一致性和安全性：

  1. 同步：多个进程同时对共享资源进行读写操作时，可能会导致数据不一致的问题。因此，需要使用同步机制来保证同一时刻只有一个进程可以访问共享资源，以避免竞态条件和数据冲突。常见的同步机制包括互斥锁、信号量、条件变量等。

  2. 互斥锁：互斥锁用于确保同一时刻只有一个进程可以进入临界区，从而避免多个进程同时访问共享资源。进程在访问共享资源之前需要先获取互斥锁，访问完成后再释放锁。

  3. 信号量：信号量用于控制多个进程对共享资源的访问权限。当共享资源可用时，信号量的值为正数；当资源被占用时，信号量的值为零或负数。进程在访问共享资源之前需要先等待信号量的值为正数，然后将信号量的值减一表示资源被占用，访问完成后再将信号量的值加一表示资源释放。

  4. 条件变量：条件变量用于在进程之间传递信号，以通知某个特定条件的发生。当进程需要等待某个条件满足时，可以使用条件变量进入睡眠状态，待条件满足时被唤醒继续执行。

  5. **文件锁：**在多个进程共享同一个文件时，可以使用文件锁来避免文件的并发访问问题。文件锁可以将文件的某个部分或整个文件锁定，从而限制其他进程对该文件的访问。

  6. 共享内存：共享内存是一种高效的进程间通信方式，多个进程可以将某块内存映射到它们的地址空间中，从而实现共享数据。在使用共享内存时，需要特别注意数据的一致性和同步问题，可以使用信号量等同步机制来保证数据的正确访问。

  通过合理的进程间资源共享策略和同步机制，可以确保多个进程之间对共享资源的安全访问，避免数据冲突和不一致的问题，保证系统的正确运行和数据的完整性。