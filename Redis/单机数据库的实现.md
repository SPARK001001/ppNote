1. **数据库**
   1. Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量由redisServer.dbnum属性保存
   
   2. 客户端通过修改目标数据库指针，让它指向redisServer.db数组中不同的元素来切换不同的数据库。
   
   3. 数据库主要由dict和expires两个字典组成，其中dict字典负责保存键值对，expires字典负责保存键的过期时间。
   
   4. 数据库由字典构成，所以数据库的操作都建立在字典的操作上。
   
   5. 数据库的键总是一个字符串对象，而值则可以使任意一种Redis对象类型，包括字符串对象、列表对象、哈希表对象、集合对象、有序集合对象。
   
   6. expires字典的键指向数据库中的某个键，值则记录了数据库键的过期时间，过期时间是一个以毫秒 为单位的unix时间戳。
   
   7. Redis使用`惰性删除和定期删除`两种策略来删除过期的键：惰性删除只是在碰到过期键时才进行删除操作，定期删除时每隔一段时间主动查找并删除过期键。
   
   8. 执行Save命令或bgsave命令生成RDB文件，不会包含过期的键。
   
   9. 执行bgrewriteaof命令重写产生的aof文件，不会包含过期的键。
   
   10. 当一个键过期被删除后，服务器会追加一条del命令到现有aof文件末尾，显式的删除过期键。
   
   11. 当主服务器删除一个过期键后，它会向所有从服务器发送一条del命令，显式的删除过期键。
   
   12. `从服务器即使发现过期键（命令调用之前会检查是否过期）也不会自作主张的删除它，而是等主服务器发来del命令，这种统一，中心化的过期键删除策略可以保证主从服务器数据的一致性。`
   
   13. 当Redis命令对服务器进行修改后，服务器会根据配置向客户端发送数据库通知。
   
   14. 命令：select 1 : 切换数据库； flushdb：清空整个数据库   ； TTL/PTTL:返回键的剩余生存时间，秒/毫秒为单位； persist key：删除键的过期时间 ； expire/pexpire/expireat/pexpireat  key .. :设置过期时间
   
       

2. **RDB持久化**

   1. RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。保存压缩的二进制文件。

   2. Save命令由服务器命令直接执行保存操作，会阻塞服务器。

   3. bgsave命令由子进程执行保存操作，不会阻塞服务器。

   4. 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行bgsave命令。`通过定时任务检查是否满足。默认3条件 save 900 1 (900秒内对数据库至少进行1次修改) ;save  300 10  ; save 60 10000`

   5. RDB文件是一个经过压缩的二进制文件，由多个部门组成。

   6. 对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。

   7. 命令： od -c dump.rdb  打印分析rdb文件   ；redis-check-dump  rdb文件检查工具。

      

3. **AOF持久化**

   1. 保存Redis服务器所执行的`写命令`来记录数据库的状态。命令以命令请求协议格式保存。

   2. aof文件写入和同步：**写入**指`aof bug `写入到`aof文件`（此时还没落盘），操作系统对文件的写入有个`内存缓冲区`，需要经过**同步**(操作系统调用fsync/fdatasync)才能将缓冲区的数据存到磁盘。

   3. aof持久化配置：appendfsync

      1. always : 将aof-buf中的所有内容写入并同步到aof文件。故障停机只会丢失一个事件循环（服务器进程就是一个事件循环，在循环中处理文件事件、时间事件、写入aof等）的命令数据。
      2. everysec : 将aof-buf（aof缓冲区）中数据`写入`aof文件，若距上次同步时间超1s，再次`同步`，由一个专门线程负责执行。故障停机 丢失1s数据。
      3. no : 将aof-buf数据写入aof文件，但同步时机由操作系统决定。

   4. `aof重写原理`：不对原来的aof文件操作，而是直接从数据库中读取键现在的值，然后用一条命令去记录键值对（若重写集合元素个数超64，会分成多个命令写，每个写64个元素），代替之前记录这个键值对的多条命令。

   5. aof后台重写：bgrewriteaof命令的实现原理

      1. 放到子进程执行重写：原因有二

         1. 子进程重写期间，服务器进程（父进程）可以继续处理命令请求。
         2. 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下保证数据的安全性。

      2. 子进程重写期间，父进程继续处理命令请求，可能会对数据库状态进行修改，导致当前数据库状态和重写后的aof文件保存的数据库状态不一致。处理步骤

         1. 使用aof重写缓冲区：在服务器创建子进程之后开始使用，当redis执行完一个写命令后，会同时将这个写命令发送给aof缓冲区（对现有aof文件处理工作如常进行）和aof重写缓冲区。

         2. 子进程aof重写完后，给父进程发送信号，父进程接收到后调用一个信号处理函数（会阻塞其他命令）：该函数会将aof重写缓冲区的内容追加写到新aof文件末尾使得新旧aof文件保存的数据库状态一致，并对新aof文件改名，原子覆盖现有aof文件，完成新旧文件替换。

            

