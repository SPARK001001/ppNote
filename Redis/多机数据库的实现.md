1.**复制**

 1. 从服务器客户端执行 slaveof ip port命令; 从服务器把主服务器的ip、port记录后回复客户端后异步执行复制。

 2. 复制分为 `同步` 和`命令传播`两部分:

     1. 旧版本：

         1. 同步 流程：

             1. 从服务器向主服务器发送sync命令。

             2. 主服务器收到sync命令执行 bgsave命令，后台生成RDB文件，用缓冲区记录生成rdb期间 所有的写命令。

             3. 主服务器bgsave命令执行完，将rdb文件发送给从服务器，从服务器接收并载入rdb,将自己数据库状态更新至主服务器执行bgsave命令时的数据库状态。

             4. 主服务器将记录在` 缓冲区`(不是aof文件) 里的所有`写命令`发送给从服务器，从服务器执行将数据库状态更新至主服务器当前数据库所处状态。
         2. 命令传播：
             1. 同步完后，主服务器接收写命令，主服务器状态改变
             2. 将执行的写命令发送给从服务器执行
           3. 旧版本缺陷：
          1. 初次复制 和 断线后重复制
               2. 断线后重复制 也会发送sync命令，导致又得生成rdb记录缓冲区来同步一次，非常消耗资源（生成rdb消耗cpu、内存、磁盘； 发送rdb消耗网络带宽和流量；从服务器接收并载入rdb，载入期间阻塞命令）。断线后应该需要的部分复制
     
     2. 新版本2.8及之后版本：
     
         1. 解决了旧版本`断线重复制`情况的低效问题， 使用PSYNC代替SYNC命令。
     
         2. PSYNC有 `完整重同步` 和 `部分重同步` 两种模式:
     
             1. 完整重同步 处理初次复制情况，和sync命令执行同步过程一样。
     
             2. 部分重同步 用于断线后重复制的情况，主服务器只需要将从服务器缺少的写命令发送给从服务器即可；通过复制偏移量，复制积压缓冲区，服务器的运行id实现。
     
                 1. 复制偏移量offset：主从服务器都有，主服务器传播N个字节数据后，就将自己复制偏移量加N。从服务器每次接收到N个字节数据，就将自己offset加N。对比主从服务器offset值，就能比较数据库状态是否一致。不一致需要进行补偿，利用复制积压缓冲区。
                 2. 复制积压缓冲区：由主服务器维护，固定大小的先进先出队列，默认1M。命令传播时会同时将写命令放入到复制积压缓冲区。缓冲区构造记录offset和命令字节值的映射。
                     1. 断线重连后，从服务器通过psync发送自己的offset到主服务器。
                     2. 若offset值+1在复制积压缓冲区，主服务器返回+CONTINUE回复，将执行部分重同步。
                     3. 若offset + 1值不在复制积压缓冲区，执行完全重同步
     
                 3. 服务器运行id:主从服务器都有各自的运行id，在启动时自动生成。
                    1. 初次复制，主服务器会把id发送给从服务器，从服务器记录。
                    2. 断线重连，从服务器将之前保存的主服务器id发送给连接的主服务器。连接的主服务器判断接收到的id与自己的运行id是否一致，一致的话进行部分重同步，否则完整重同步。
     
         3. psync执行完整重同步和部分重同步可能遇到的情况![image-20220903082553616](\img\image-20220903082553616.png)
     
 3. 复制的详细实现步骤：
        1. SLAVEOF设置主服务器的地址和端口
        
         2. 从服务器建立连向主服务器的套接字连接。

         3. 从服务器发送ping命令：检查套接字读写状态是否正常 以及 主服务器是否正常处理命令请求。
            1. 从服务器读取到“PONG”回复，连接正常，继续执行复制的下一个步骤。
            2. 从服务读取ping命令的回复超时或主服务器返回一个错误，断开并重连主服务器。

         4. 身份验证：如果从服务器设置了masterauth选项的话。![image-20220903083657649](\img\image-20220903083657649.png)
       5. 发送端口信息：从服务器执行replconf listening-port <port>,主服务器记录端口号。

         6. 同步：从服务器发送psync命令
            
         7. 命令传播：将自己执行的写命令发送给从服务器

 4. 心跳检测

     1. 命令传播阶段，从服务器每秒一次发送 REPLCONF ACK <replication_offset>给主服务器。三作用

          1. 检测主从服务器的网络连接状态： 主服务超过一秒没接收到，主服务器就知道主从连接有问题了。主服务器上执行info replication 中slave的lag属性值，应该在0-1s之间。

          2. 辅助实现min-slaves选项：防止 主服务器在不安全情况下执行写命令

               1. min-slaves-to-write 3

               2. min-slave-max-lag 10

                    从服务器少于3，或三从服务器延迟都大于等于10s,主服务器将拒绝执行写命令。

          3. 检测命令丢失：可能命令传播过程有命令丢失了。这时replconf发送的offset与主服务器的offset不一致，主服务器补发缺失的数据，去复制积压缓冲区里找到并补发。与部分重复制的区别是 这发生在`没有断线`的情况下。



2. **sentinel**
   1. 是Redis高可用的解决方案：多个sentinl节点的系统
      1. 判断主客观下线
      2. 选择sentinel领导者并进行自动故障转移
   2. 每个sentinel节点保存了主节点、从节点、其他sentinel节点的结构信息。一个sentinel节点可以通过分析接收到的频道信息来获知其他sentinel的存在，监视同一个主服务器的多个sentinel可以自动发现对方。
   3. 检测主观下线状态：每秒一次发送ping命令给与它创建命令连接的实例（主 从服务器、其他sentinel），根据回复来判断实例是否在线，不在线时 更新保存在sentinel对应的实例结构。多个sentinel设置的主观下线时长可能不同。
   4. 检查客观下线状态：
      1. 客观下线状态的判断条件：当认为主服务器下线的sentinel数量超过sentinel配置的`quorum`参数，那么该sentinel就认为主服务器客观下线了。
      2. 不同sentinel判断客观下线的条件可能不同
   5. 选举领头sentinel进行故障转移
      1. 每个发现主服务器进入客观下线的sentinel都会发起选举，选举需要`半数`以上sentinel节点支持。
      2. 选举不成功，进行下一次选举。
   6. 故障转移
      1. 在从服务器列表中挑选出一个，设置为主服务器。slaveof  no one
         1. 删除下线或断线等不健康的从服务器。
         2. 删除最近5s没回复过领头sentinel info命令的从服务器。
         3. 删除所有与已下线主服务器 连接断开超过 down-after-millisenconds * 10 ms的从服务器。
         4. 从服务器的优先级，优先级高的选中。
         5. 否则挑选复制偏移量最大的从服务器。
         6. 否则挑选runid最小的从服务器。
      2. 让下线主服务器属下所有从服务器改为复制新的主服务器。
      3. 让已下线主服务器设置为新的主服务器的从服务器。 



3. **集群**
   1. 节点通过握手来将其他节点添加到自己所处的集群中。Redis集群是Redis提供的分布式解决方案，通过分片进行数据共享，并提供复制和故障转移功能。
   2. 集群中16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给自己，哪些槽又被指派给其他节点
   3. 节点在接到一个命令请求，先检查这个命令请求要处理的键所在的槽是否由自己负责，不是的话，给客户端返回moved错误，moved错误携带的信息可以指引客户端转向正在负责相关槽的节点。
   4. 对redis集群的重新分片工作由redis-trib负责执行，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。
   5. 若节点A正在迁移槽i至节点B,当节点A没能找到键，节点A给客户端返回一个ASK错误，指引客户端到节点B继续查找。
   6. 复制：cluster replicate <node_id> 让接受命令的节点称为node_id的从节点，并开始进行复制。并通过发送消息到集群中其他节点，最终其他节点会知道某个从节点正在复制某个主节点，这些节点会记录主节点的从节点信息。
   7. 消息：
      1. Redis集群中各个节点通过Gossip协议来交换各自关于不同节点的状态信息，Gossip协议由meet/ping/pong三种消息实现。
      2. fail消息的实现：广播已下线信息的应用
      3. publish消息的实现
   8. 故障检测：集群中每个节点都会定期向其他节点发送ping消息，若没在规定时间收到回复的pong消息，标记为疑似下线。节点通过相互发送消息交换集群中各个节点的状态信息。`半数以上`负责处理槽(不包括x主节点)的主节点将某个主节点x标记为疑似下线，那该主节点将被标记为 `已下线`。广播出去，集群其他节点都标记该主节点为已下线。
   9. 故障转移：
      1. 从节点发现自己复制的主节点状态为已下线，开始进行故障转移。
      2. 选举一个从节点成为新的主节点：基于raft算法选举
         1. 从节点广播消息，要求成为主节点。
         2. 负责处理槽的主节点 收到消息并 尚未投给其他从节点，那就投给该从节点，先到先得。
         3. 大于 N/2 张投票，将成为主节点。
         4. 若该配置纪元未产生主节点，开始新一轮投票选举。
      3. 选中的从节点执行slaveof no one，成为主节点。
      4. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽指派给自己
      5. 新主节点广播一条pong消息，让集群其他节点知晓
      6. 新主节点开始接收和自己负责处理的槽有关的命令，故障转移完成。



