**常用集合类：** 熟悉ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap等常用集合类的特点、适用场景和性能。

- 当涉及到常用的集合类时，以下是每个集合类的特点、适用场景和性能概述：

  1. **ArrayList：**
     - 特点：基于动态数组实现，支持快速随机访问，读取速度较快。
     - 适用场景：适用于频繁读取和少量插入/删除操作的场景。
     - 性能：读取元素的性能很好，插入/删除元素的性能取决于位置，插入/删除元素会导致数组元素的移动。

  2. **LinkedList：**
     - 特点：基于双向链表实现，支持高效的插入和删除操作，对于插入/删除操作性能较好。
     - 适用场景：适用于需要频繁插入和删除元素，但不需要随机访问的场景。
     - 性能：插入/删除元素的性能较好，随机访问元素的性能较差。

  3. **HashSet：**
     - 特点：基于哈希表实现，无序、不可重复。
     - 适用场景：适用于需要存储唯一元素的场景，不关心元素顺序。
     - 性能：查找元素的性能很好，插入/删除元素的性能也很好，但不保持元素的插入顺序。

  4. **LinkedHashSet：**
     - 特点：基于哈希表和双向链表实现，保持插入顺序，不可重复。
     - 适用场景：适用于需要保持元素插入顺序且不允许重复的场景。
     - 性能：查找、插入和删除元素的性能较好。

  5. **TreeSet：**
     - 特点：基于红黑树实现，有序、不可重复。
     - 适用场景：适用于需要有序存储元素且不允许重复的场景。
     - 性能：查找元素的性能较好，但插入/删除元素的性能较HashSet和LinkedHashSet略低。

  6. **HashMap：**
     - 特点：基于哈希表实现，使用键值对存储。
     - 适用场景：适用于存储键值对，并且不需要保持特定顺序的场景。
     - 性能：查找键对应的值的性能很好，插入/删除键值对的性能也很好。

  7. **LinkedHashMap：**
     - 特点：基于哈希表和双向链表实现，保持插入顺序，使用键值对存储。
     - 适用场景：适用于需要保持插入顺序的键值对存储场景。
     - 性能：查找键对应的值的性能较好，插入/删除键值对的性能也较好。

  8. **TreeMap：**
     - 特点：基于红黑树实现，使用键值对存储，保持键的有序性。
     - 适用场景：适用于需要有序存储键值对的场景。
     - 性能：查找键对应的值的性能较好，但插入/删除键值对的性能相对较HashSet和LinkedHashSet略低。

  根据集合的特点和适用场景，选择合适的集合类可以提高代码的性能和可维护性。